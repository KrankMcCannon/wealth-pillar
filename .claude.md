# Wealth Pillar - Business Logic Documentation

## Table of Contents

1. [Architecture Principles](#architecture-principles)
2. [Folder Structure](#folder-structure)
3. [Business Logic Layers](#business-logic-layers)
4. [Domain-Driven Design](#domain-driven-design)
5. [Caching Strategy](#caching-strategy)
6. [Data Fetching Patterns](#data-fetching-patterns)
7. [Error Handling](#error-handling)
8. [Usage Examples](#usage-examples)
9. [Adding New Features](#adding-new-features)
10. [Best Practices](#best-practices)

---

## Architecture Principles

This codebase follows **SOLID** and **DRY** principles to ensure maintainability, scalability, and testability.

### SOLID Principles

#### 1. Single Responsibility Principle (SRP)
- **Each service class handles ONE domain** (User, Group, Account, etc.)
- **Each function has ONE purpose** (get user, get group users, etc.)
- **Separation of concerns**: UI components, business logic, and data access are separated

**Example:**
```typescript
// ✅ GOOD - UserService only handles user operations
class UserService {
  static async getLoggedUserInfo(clerkId: string) { ... }
  static async getUserById(userId: string) { ... }
}

// ❌ BAD - Mixed responsibilities
class DataService {
  static async getUser() { ... }
  static async getAccount() { ... }
  static async getTransaction() { ... }
}
```

#### 2. Open/Closed Principle (OCP)
- **Services are open for extension, closed for modification**
- Add new methods without changing existing code
- Extend functionality through inheritance or composition

**Example:**
```typescript
// Add new functionality without modifying existing methods
class UserService {
  // Existing methods remain unchanged
  static async getUserById(userId: string) { ... }

  // NEW: Extend with additional methods
  static async getUsersByRole(role: string) { ... }
}
```

#### 3. Liskov Substitution Principle (LSP)
- **All services return consistent `ServiceResult<T>` type**
- Services can be swapped without breaking code
- Predictable behavior across all service methods

**Example:**
```typescript
// All services use the same result type
const userResult: ServiceResult<User> = await UserService.getUserById(id);
const groupResult: ServiceResult<Group> = await GroupService.getGroupById(id);

// Both can be handled the same way
if (userResult.error) { ... }
if (groupResult.error) { ... }
```

#### 4. Interface Segregation Principle (ISP)
- **Services expose only what clients need**
- Lightweight methods for simple operations (exists checks, counts)
- Full methods for complete data retrieval

**Example:**
```typescript
// Lightweight check (only returns boolean)
await UserService.userExistsByClerkId(clerkId);

// Full data retrieval (returns complete user object)
await UserService.getUserById(userId);
```

#### 5. Dependency Inversion Principle (DIP)
- **Services depend on abstractions** (Supabase client interface)
- **High-level modules don't depend on low-level modules**
- Easy to swap database implementation if needed

**Example:**
```typescript
// Services use the abstracted Supabase client
import { supabaseServer } from '@/lib/database/server';

// Not directly creating clients
const client = supabaseServer.from('users');
```

### DRY Principle (Don't Repeat Yourself)

- **Centralized cache configuration** in `/src/lib/cache/config.ts`
- **Reusable cache key generators** in `/src/lib/cache/keys.ts`
- **Shared types and utilities** prevent duplication
- **Service layer eliminates duplicate database queries** across components

---

## Folder Structure

```
wealth-pillar/
├── .claude.md                           # This documentation file
├── app/                                 # Next.js App Router
│   ├── (auth)/                          # Authentication routes
│   └── (dashboard)/                     # Dashboard routes
│
├── src/
│   ├── lib/                             # Core infrastructure
│   │   ├── cache/                       # Caching layer
│   │   │   ├── config.ts                # Cache TTL and tags configuration
│   │   │   ├── keys.ts                  # Cache key generators
│   │   │   └── index.ts                 # Cache utilities wrapper
│   │   │
│   │   ├── database/                    # Database layer
│   │   │   ├── server.ts                # Supabase server client (NEW)
│   │   │   └── types.ts                 # Database TypeScript types
│   │   │
│   │   ├── services/                    # Business logic layer (NEW)
│   │   │   ├── user.service.ts          # User domain logic
│   │   │   ├── group.service.ts         # Group domain logic
│   │   │   ├── transaction.service.ts   # Transaction domain logic
│   │   │   └── index.ts                 # Service exports
│   │   │
│   │   ├── types/                       # Shared TypeScript types
│   │   └── utils/                       # Utility functions
│   │
│   ├── features/                        # Feature modules
│   │   ├── auth/                        # Authentication feature
│   │   ├── dashboard/                   # Dashboard feature
│   │   ├── accounts/                    # Accounts feature
│   │   └── .../                         # Other features
│   │
│   └── components/                      # Shared UI components
│       ├── ui/                          # Primitives (buttons, inputs, etc.)
│       ├── layout/                      # Layout components
│       └── shared/                      # Shared components
```

### Key Directories

#### `/src/lib/services/` - Business Logic Layer
- **Purpose**: Contains all domain business logic
- **Pattern**: One service per domain (User, Group, Account, etc.)
- **Responsibility**: Data fetching, validation, transformation, caching

#### `/src/lib/cache/` - Caching Infrastructure
- **Purpose**: Centralized caching configuration and utilities
- **Components**:
  - `config.ts`: TTL values and cache tags
  - `keys.ts`: Cache key generators
  - `index.ts`: Wrapper around Next.js unstable_cache

#### `/src/lib/database/` - Data Access Layer
- **Purpose**: Database client configuration and types
- **Components**:
  - `server.ts`: Server-side Supabase client
  - `types.ts`: Generated database types

---

## Business Logic Layers

### 1. Data Access Layer (Database)
**Location**: `/src/lib/database/server.ts`

**Responsibilities**:
- Create and configure Supabase client
- Manage database connections
- Provide typed database access

**Usage**:
```typescript
import { supabaseServer } from '@/lib/database/server';

const { data, error } = await supabaseServer
  .from('users')
  .select('*')
  .eq('id', userId);
```

### 2. Business Logic Layer (Services)
**Location**: `/src/lib/services/`

**Responsibilities**:
- Implement domain logic
- Validate inputs
- Handle errors consistently
- Apply caching strategies
- Transform data when needed

**Usage**:
```typescript
import { UserService } from '@/lib/services';

const { data: user, error } = await UserService.getLoggedUserInfo(clerkId);
```

### 3. Presentation Layer (Components)
**Location**: `/src/features/{domain}/components/`

**Responsibilities**:
- Render UI
- Handle user interactions
- Call service methods for data
- Display loading/error states

**Usage**:
```typescript
// In a Server Component
import { UserService } from '@/lib/services';

export default async function UserProfile({ clerkId }: Props) {
  const { data: user, error } = await UserService.getLoggedUserInfo(clerkId);

  if (error) return <ErrorMessage error={error} />;
  return <ProfileCard user={user} />;
}
```

---

## Domain-Driven Design

### Current Domains

#### 1. User Domain
**Service**: `UserService`
**Database Table**: `users`

**Operations**:
- `getLoggedUserInfo(clerkId)` - Get user by Clerk ID
- `getUserById(userId)` - Get user by internal ID
- `userExistsByClerkId(clerkId)` - Check if user exists
- `getUserGroupId(userId)` - Get user's group ID

**Use Cases**:
- Authentication flows
- Profile display
- Permission checks
- User management

#### 2. Group Domain
**Service**: `GroupService`
**Database Table**: `groups`

**Operations**:
- `getGroupById(groupId)` - Get group details
- `getGroupUsers(groupId)` - Get all users in group
- `getGroupUserCount(groupId)` - Get member count
- `getUsersByRole(groupId, role)` - Get users by role
- `groupExists(groupId)` - Check if group exists
- `getGroupWithUserCount(groupId)` - Get group with member count

**Use Cases**:
- Team collaboration
- Group dashboards
- Member management
- Role-based access control

#### 3. Transaction Domain
**Service**: `TransactionService`
**Database Table**: `transactions`

**Operations**:
- `getTransactionsByGroup(groupId)` - Get all transactions for a group (sorted by date desc)
- `getTransactionsByUser(userId)` - Get all transactions for a user (sorted by date desc)
- `getTransactionsByAccount(accountId)` - Get all transactions for an account (includes both account_id and to_account_id, sorted by date desc)
- `calculateReportMetrics(transactions, userId?)` - Calculate income, expenses, savings, and category breakdown from transactions
- `groupTransactionsByDate(transactions, locale?)` - Group transactions by formatted date
- `calculateDailyTotals(groupedTransactions)` - Calculate daily net totals from grouped transactions

**Use Cases**:
- Transaction history display
- Group-wide financial tracking
- Personal transaction management
- Account statement generation
- Transfer tracking (incoming and outgoing)
- Financial reports and analytics
- Daily transaction summaries
- Category spending analysis

**Cache Strategy**:
- TTL: 120 seconds (2 minutes)
- Tags: `transactions`, `user:{userId}:transactions`, `account:{accountId}:transactions`, `group:{groupId}:transactions`

**Business Logic Methods**:
All calculation methods are pure functions (no database calls, no caching):
- `calculateReportMetrics()` - Pure calculation logic for financial reports
- `groupTransactionsByDate()` - Pure grouping logic
- `calculateDailyTotals()` - Pure calculation logic for daily summaries

### Future Domains (To Be Implemented)

#### 4. Account Domain
**Service**: `AccountService` (to be created)
**Database Table**: `accounts`

**Planned Operations**:
- `getAccountById(accountId)`
- `getAccountsByUser(userId)`
- `getAccountsByGroup(groupId)`
- `calculateAccountBalance(accountId)`

#### 5. Budget Domain
**Service**: `BudgetService` (to be created)
**Database Table**: `budgets`

**Planned Operations**:
- `getBudgetById(budgetId)`
- `getBudgetsByUser(userId)`
- `calculateBudgetProgress(budgetId)`

---

## Caching Strategy

### Next.js 15 Server-Side Caching

We use **Next.js `unstable_cache`** for server-side data caching with **SSR (Server-Side Rendering)**.

### Cache Configuration

**Location**: `/src/lib/cache/config.ts`

#### TTL (Time-To-Live) Values
```typescript
CACHE_TTL = {
  USER: 300,         // 5 minutes - frequently accessed
  GROUP: 600,        // 10 minutes - less frequent changes
  ACCOUNT: 300,      // 5 minutes
  TRANSACTION: 120,  // 2 minutes - frequently updated
  CATEGORY: 900,     // 15 minutes - rarely changes
  BUDGET: 300,       // 5 minutes
  STATIC: 3600,      // 1 hour - static data
}
```

#### Cache Tags for Invalidation
```typescript
CACHE_TAGS = {
  USERS: 'users',
  USER: (userId) => `user:${userId}`,
  USER_BY_CLERK: (clerkId) => `user:clerk:${clerkId}`,
  GROUPS: 'groups',
  GROUP: (groupId) => `group:${groupId}`,
  GROUP_USERS: (groupId) => `group:${groupId}:users`,
}
```

### Cache Keys

**Location**: `/src/lib/cache/keys.ts`

Consistent cache key generation:
```typescript
userCacheKeys = {
  byId: (userId) => ['user', 'id', userId],
  byClerkId: (clerkId) => ['user', 'clerk', clerkId],
}
```

### How Caching Works

1. **First Request**: Data is fetched from database and cached
2. **Subsequent Requests**: Data is served from cache (within TTL)
3. **After TTL**: Cache expires, fresh data is fetched and cached again
4. **Manual Invalidation**: Use `revalidateTag()` to force refresh

### Cache Invalidation

**When to invalidate**:
- After data mutations (create, update, delete)
- When data becomes stale
- After user actions that change data

**How to invalidate**:
```typescript
import { revalidateTag } from 'next/cache';
import { CACHE_TAGS } from '@/lib/cache';

// Invalidate specific user
revalidateTag(CACHE_TAGS.USER(userId));

// Invalidate all users
revalidateTag(CACHE_TAGS.USERS);

// Invalidate group users
revalidateTag(CACHE_TAGS.GROUP_USERS(groupId));
```

**Example in Server Action**:
```typescript
'use server';

import { revalidateTag } from 'next/cache';
import { CACHE_TAGS } from '@/lib/cache';

export async function updateUser(userId: string, data: UpdateData) {
  // Update user in database
  await supabaseServer
    .from('users')
    .update(data)
    .eq('id', userId);

  // Invalidate user cache
  revalidateTag(CACHE_TAGS.USER(userId));
  revalidateTag(CACHE_TAGS.USERS);
}
```

---

## Data Fetching Patterns

### Server Components (RSC) - Primary Pattern

**Best for**: Initial page loads, SEO-critical data

**Example**:
```typescript
// app/(dashboard)/profile/page.tsx
import { UserService, GroupService } from '@/lib/services';
import { auth } from '@clerk/nextjs';

export default async function ProfilePage() {
  // Get authenticated user from Clerk
  const { userId: clerkId } = await auth();

  if (!clerkId) {
    redirect('/sign-in');
  }

  // Fetch user data on server (cached automatically)
  const { data: user, error: userError } =
    await UserService.getLoggedUserInfo(clerkId);

  if (userError || !user) {
    return <ErrorPage error={userError} />;
  }

  // Fetch group users (cached automatically)
  const { data: groupUsers, error: groupError } =
    await GroupService.getGroupUsers(user.group_id);

  if (groupError) {
    return <ErrorPage error={groupError} />;
  }

  return (
    <div>
      <UserProfile user={user} />
      <GroupMembers users={groupUsers} />
    </div>
  );
}
```

### Parallel Data Fetching

**Best for**: Multiple independent data sources

**Example**:
```typescript
export default async function DashboardPage() {
  const { userId: clerkId } = await auth();

  // Fetch user data
  const { data: user } = await UserService.getLoggedUserInfo(clerkId);

  if (!user) return <ErrorPage />;

  // Fetch multiple data sources in parallel
  const [groupResult, accountsResult, transactionsResult] =
    await Promise.all([
      GroupService.getGroupUsers(user.group_id),
      AccountService.getAccountsByUser(user.id),
      TransactionService.getRecentTransactions(user.id),
    ]);

  return (
    <Dashboard
      user={user}
      groupUsers={groupResult.data}
      accounts={accountsResult.data}
      transactions={transactionsResult.data}
    />
  );
}
```

### Nested Data Fetching

**Best for**: Component composition

**Example**:
```typescript
// Parent component
export default async function GroupPage({ groupId }: Props) {
  const { data: group } = await GroupService.getGroupById(groupId);

  return (
    <div>
      <GroupHeader group={group} />
      <GroupMembers groupId={groupId} />  {/* Child fetches own data */}
    </div>
  );
}

// Child component
async function GroupMembers({ groupId }: { groupId: string }) {
  const { data: users } = await GroupService.getGroupUsers(groupId);

  return (
    <ul>
      {users.map(user => <MemberCard key={user.id} user={user} />)}
    </ul>
  );
}
```

### Loading States with Suspense

**Example**:
```typescript
// app/(dashboard)/profile/page.tsx
import { Suspense } from 'react';

export default function ProfilePage() {
  return (
    <div>
      <Suspense fallback={<UserProfileSkeleton />}>
        <UserProfile />
      </Suspense>

      <Suspense fallback={<GroupMembersSkeleton />}>
        <GroupMembers />
      </Suspense>
    </div>
  );
}

async function UserProfile() {
  const { userId } = await auth();
  const { data: user } = await UserService.getLoggedUserInfo(userId);
  return <ProfileCard user={user} />;
}

async function GroupMembers() {
  const { userId } = await auth();
  const { data: user } = await UserService.getLoggedUserInfo(userId);
  const { data: members } = await GroupService.getGroupUsers(user.group_id);
  return <MembersList members={members} />;
}
```

---

## Error Handling

### ServiceResult Pattern

All services return `ServiceResult<T>`:
```typescript
interface ServiceResult<T> {
  data: T | null;
  error: string | null;
}
```

### Error Handling in Server Components

```typescript
export default async function Page() {
  const { data, error } = await UserService.getUserById(userId);

  // Pattern 1: Early return
  if (error) {
    return <ErrorMessage error={error} />;
  }

  // Pattern 2: Conditional rendering
  return error
    ? <ErrorMessage error={error} />
    : <UserProfile user={data} />;
}
```

### Error Boundary for Client Components

```typescript
// app/error.tsx
'use client';

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  return (
    <div>
      <h2>Something went wrong!</h2>
      <p>{error.message}</p>
      <button onClick={reset}>Try again</button>
    </div>
  );
}
```

### Validation Errors

All service methods validate inputs:
```typescript
static async getUserById(userId: string): Promise<ServiceResult<User>> {
  // Input validation
  if (!userId || userId.trim() === '') {
    return {
      data: null,
      error: 'User ID is required',
    };
  }

  // Database operation
  // ...
}
```

---

## Usage Examples

### Example 1: User Profile Page

```typescript
// app/(dashboard)/profile/page.tsx
import { UserService, GroupService } from '@/lib/services';
import { auth } from '@clerk/nextjs';
import { redirect } from 'next/navigation';

export default async function ProfilePage() {
  // Get authenticated user's Clerk ID
  const { userId: clerkId } = await auth();

  if (!clerkId) {
    redirect('/sign-in');
  }

  // Fetch logged-in user info (cached for 5 minutes)
  const { data: user, error } = await UserService.getLoggedUserInfo(clerkId);

  if (error || !user) {
    return <div>Error loading profile: {error}</div>;
  }

  // Fetch all users in the same group (cached for 10 minutes)
  const { data: groupUsers } = await GroupService.getGroupUsers(user.group_id);

  return (
    <div>
      <h1>Welcome, {user.name}!</h1>
      <p>Email: {user.email}</p>
      <p>Role: {user.role}</p>

      <h2>Your Team Members ({groupUsers?.length || 0})</h2>
      <ul>
        {groupUsers?.map(member => (
          <li key={member.id}>
            {member.name} ({member.role})
          </li>
        ))}
      </ul>
    </div>
  );
}
```

### Example 2: Dashboard with Multiple Data Sources

```typescript
// app/(dashboard)/dashboard/page.tsx
import { UserService, GroupService, AccountService } from '@/lib/services';
import { auth } from '@clerk/nextjs';

export default async function DashboardPage() {
  const { userId: clerkId } = await auth();

  // Get logged user
  const { data: user } = await UserService.getLoggedUserInfo(clerkId!);

  if (!user) return <div>User not found</div>;

  // Fetch all data in parallel for better performance
  const [groupResult, accountsResult, membersCountResult] = await Promise.all([
    GroupService.getGroupById(user.group_id),
    AccountService.getAccountsByUser(user.id),
    GroupService.getGroupUserCount(user.group_id),
  ]);

  return (
    <div>
      <h1>Dashboard</h1>

      <section>
        <h2>{groupResult.data?.name}</h2>
        <p>{membersCountResult.data} members</p>
      </section>

      <section>
        <h2>Your Accounts</h2>
        {accountsResult.data?.map(account => (
          <AccountCard key={account.id} account={account} />
        ))}
      </section>
    </div>
  );
}
```

### Example 3: Server Action with Cache Invalidation

```typescript
// app/actions/user.actions.ts
'use server';

import { revalidateTag } from 'next/cache';
import { supabaseServer } from '@/lib/database/server';
import { CACHE_TAGS } from '@/lib/cache';

export async function updateUserProfile(
  userId: string,
  data: { name: string; avatar: string }
) {
  try {
    // Update user in database
    const { error } = await supabaseServer
      .from('users')
      .update({
        name: data.name,
        avatar: data.avatar,
        updated_at: new Date().toISOString(),
      })
      .eq('id', userId);

    if (error) {
      return { success: false, error: error.message };
    }

    // Invalidate user cache
    revalidateTag(CACHE_TAGS.USER(userId));
    revalidateTag(CACHE_TAGS.USERS);

    return { success: true, error: null };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}
```

---

## Adding New Features

### Step-by-Step Guide to Add a New Domain

Let's add an **Account** domain as an example.

#### Step 1: Add Cache Configuration

**File**: `/src/lib/cache/config.ts`

```typescript
export const CACHE_TTL = {
  // ... existing
  ACCOUNT: 300, // 5 minutes
}

export const CACHE_TAGS = {
  // ... existing
  ACCOUNTS: 'accounts',
  ACCOUNT: (accountId: string) => `account:${accountId}`,
  USER_ACCOUNTS: (userId: string) => `user:${userId}:accounts`,
}

export const cacheOptions = {
  // ... existing
  account: (accountId: string) => ({
    revalidate: CACHE_TTL.ACCOUNT,
    tags: [CACHE_TAGS.ACCOUNTS, CACHE_TAGS.ACCOUNT(accountId)],
  }),

  userAccounts: (userId: string) => ({
    revalidate: CACHE_TTL.ACCOUNT,
    tags: [CACHE_TAGS.ACCOUNTS, CACHE_TAGS.USER_ACCOUNTS(userId)],
  }),
}
```

#### Step 2: Add Cache Keys

**File**: `/src/lib/cache/keys.ts`

```typescript
export const accountCacheKeys = {
  byId: (accountId: string) => ['account', 'id', accountId] as const,
  byUser: (userId: string) => ['accounts', 'user', userId] as const,
  byGroup: (groupId: string) => ['accounts', 'group', groupId] as const,
}
```

#### Step 3: Create Service

**File**: `/src/lib/services/account.service.ts`

```typescript
import { supabaseServer } from '@/lib/database/server';
import { cached, accountCacheKeys, cacheOptions } from '@/lib/cache';
import type { Database } from '@/lib/database/types';
import type { ServiceResult } from './user.service';

type Account = Database['public']['Tables']['accounts']['Row'];

export class AccountService {
  static async getAccountById(
    accountId: string
  ): Promise<ServiceResult<Account>> {
    try {
      if (!accountId || accountId.trim() === '') {
        return { data: null, error: 'Account ID is required' };
      }

      const getCachedAccount = cached(
        async () => {
          const { data, error } = await supabaseServer
            .from('accounts')
            .select('*')
            .eq('id', accountId)
            .single();

          if (error) throw new Error(error.message);
          return data;
        },
        accountCacheKeys.byId(accountId),
        cacheOptions.account(accountId)
      );

      const account = await getCachedAccount();

      if (!account) {
        return { data: null, error: 'Account not found' };
      }

      return { data: account, error: null };
    } catch (error) {
      return {
        data: null,
        error: error instanceof Error
          ? error.message
          : 'Failed to retrieve account',
      };
    }
  }

  static async getAccountsByUser(
    userId: string
  ): Promise<ServiceResult<Account[]>> {
    try {
      if (!userId || userId.trim() === '') {
        return { data: null, error: 'User ID is required' };
      }

      const getCachedAccounts = cached(
        async () => {
          const { data, error } = await supabaseServer
            .from('accounts')
            .select('*')
            .eq('user_id', userId)
            .order('created_at', { ascending: false });

          if (error) throw new Error(error.message);
          return data || [];
        },
        accountCacheKeys.byUser(userId),
        cacheOptions.userAccounts(userId)
      );

      const accounts = await getCachedAccounts();

      return { data: accounts, error: null };
    } catch (error) {
      return {
        data: null,
        error: error instanceof Error
          ? error.message
          : 'Failed to retrieve accounts',
      };
    }
  }
}
```

#### Step 4: Export Service

**File**: `/src/lib/services/index.ts`

```typescript
export { UserService } from './user.service';
export { GroupService } from './group.service';
export { AccountService } from './account.service'; // NEW

export type { ServiceResult } from './user.service';
```

#### Step 5: Use in Components

**File**: `app/(dashboard)/accounts/page.tsx`

```typescript
import { UserService, AccountService } from '@/lib/services';
import { auth } from '@clerk/nextjs';

export default async function AccountsPage() {
  const { userId: clerkId } = await auth();
  const { data: user } = await UserService.getLoggedUserInfo(clerkId!);

  if (!user) return <div>User not found</div>;

  const { data: accounts, error } = await AccountService.getAccountsByUser(user.id);

  if (error) return <div>Error: {error}</div>;

  return (
    <div>
      <h1>Your Accounts</h1>
      {accounts?.map(account => (
        <AccountCard key={account.id} account={account} />
      ))}
    </div>
  );
}
```

#### Step 6: Update Documentation

Update this `.claude.md` file with the new domain information.

---

## Best Practices

### 1. Always Use Services for Data Fetching

❌ **Don't do this**:
```typescript
// Direct database access in components
const { data } = await supabaseServer.from('users').select('*');
```

✅ **Do this**:
```typescript
// Use service layer
const { data, error } = await UserService.getUserById(userId);
```

### 2. Handle Errors Consistently

❌ **Don't do this**:
```typescript
const { data } = await UserService.getUserById(userId);
// No error handling - data might be null!
console.log(data.name); // Potential error
```

✅ **Do this**:
```typescript
const { data, error } = await UserService.getUserById(userId);
if (error || !data) {
  return <ErrorPage error={error} />;
}
console.log(data.name); // Safe
```

### 3. Invalidate Cache After Mutations

❌ **Don't do this**:
```typescript
'use server';
export async function updateUser(userId: string, data: any) {
  await supabaseServer.from('users').update(data).eq('id', userId);
  // Cache is now stale!
}
```

✅ **Do this**:
```typescript
'use server';
import { revalidateTag } from 'next/cache';
import { CACHE_TAGS } from '@/lib/cache';

export async function updateUser(userId: string, data: any) {
  await supabaseServer.from('users').update(data).eq('id', userId);
  revalidateTag(CACHE_TAGS.USER(userId)); // Invalidate cache
}
```

### 4. Use Parallel Fetching When Possible

❌ **Don't do this** (sequential):
```typescript
const user = await UserService.getUserById(userId);
const group = await GroupService.getGroupById(user.data!.group_id);
const accounts = await AccountService.getAccountsByUser(userId);
// Takes: Time(user) + Time(group) + Time(accounts)
```

✅ **Do this** (parallel):
```typescript
const user = await UserService.getUserById(userId);

const [groupResult, accountsResult] = await Promise.all([
  GroupService.getGroupById(user.data!.group_id),
  AccountService.getAccountsByUser(userId),
]);
// Takes: Max(Time(group), Time(accounts))
```

### 5. Use Server Components for Data Fetching

❌ **Don't do this**:
```typescript
'use client';
import { useEffect, useState } from 'react';

export default function UserProfile() {
  const [user, setUser] = useState(null);

  useEffect(() => {
    // Client-side fetching - slower, no SSR benefits
    fetch('/api/user').then(res => res.json()).then(setUser);
  }, []);

  // ...
}
```

✅ **Do this**:
```typescript
// Server Component - faster, SEO-friendly, cached
import { UserService } from '@/lib/services';

export default async function UserProfile() {
  const { data: user } = await UserService.getUserById(userId);
  // ...
}
```

### 6. Validate Inputs in Service Methods

✅ **Always validate**:
```typescript
static async getUserById(userId: string): Promise<ServiceResult<User>> {
  // Input validation
  if (!userId || userId.trim() === '') {
    return { data: null, error: 'User ID is required' };
  }

  // Proceed with database operation
  // ...
}
```

### 7. Use TypeScript Types from Database

✅ **Import from database types**:
```typescript
import type { Database } from '@/lib/database/types';

type User = Database['public']['Tables']['users']['Row'];
type UserInsert = Database['public']['Tables']['users']['Insert'];
type UserUpdate = Database['public']['Tables']['users']['Update'];
```

### 8. Document Your Code

✅ **Add JSDoc comments**:
```typescript
/**
 * Retrieves logged-in user information by Clerk ID
 * Used for authentication flows where we have the Clerk user ID
 *
 * @param clerkId - Clerk authentication ID
 * @returns User data or error
 *
 * @example
 * const { data: user, error } = await UserService.getLoggedUserInfo(clerkId);
 */
static async getLoggedUserInfo(clerkId: string): Promise<ServiceResult<User>> {
  // ...
}
```

---

## Implementation Status

### Completed Features ✅

#### Core Infrastructure
- ✅ **Supabase Server Client** (`src/lib/database/server.ts`)
  - Server-side client with service role key
  - Singleton pattern for optimal performance
  - Full TypeScript support

- ✅ **Cache Infrastructure** (`src/lib/cache/`)
  - Cache configuration with TTL values
  - Cache key generators (DRY principle)
  - Wrapper around Next.js `unstable_cache`
  - Tag-based invalidation support

- ✅ **Service Layer** (`src/lib/services/`)
  - `UserService` - User operations with caching
  - `GroupService` - Group and team member operations
  - `TransactionService` - Transaction operations, business logic, and analytics
  - Consistent `ServiceResult<T>` pattern
  - Input validation on all methods
  - Comprehensive JSDoc documentation
  - Pure business logic methods for calculations

- ✅ **Shared Utility** (`src/lib/auth/get-dashboard-data.ts`)
  - `getDashboardData()` - Single function for all pages
  - Handles authentication and data fetching
  - `DashboardDataProps` interface for type safety
  - Consistent error handling across all pages
  - **70% code reduction** in page files

#### Page Implementations (Server Components)

All dashboard pages have been converted to **Server Components** for optimal SSR performance:

**✅ Dashboard Page** (`app/(dashboard)/dashboard/`)
- Server Component fetches user and group data
- Client Component handles state management
- Real user data displayed in header
- UserSelector component fully functional
- Interactive modal handlers wired up

**✅ Settings Page** (`app/(dashboard)/settings/`)
- User profile display with real data
- Avatar with user initials and theme color
- Group members list with real data
- Member count and role badges
- Email, role, and user stats display

**✅ Transactions Page** (`app/(dashboard)/transactions/`)
- Server-side transaction fetching with TransactionService
- User filtering and transaction grouping
- Tab navigation (Transactions/Recurrent)
- Daily transaction summaries with totals
- Uses TransactionService methods for grouping and calculations
- Interactive state management and modal triggers

**✅ Budgets Page** (`app/(dashboard)/budgets/`)
- Server-side user data fetching
- Ready for budget service integration

**✅ Investments Page** (`app/(dashboard)/investments/`)
- Server-side user data fetching
- Ready for investment service integration

**✅ Reports Page** (`app/(dashboard)/reports/`)
- Server-side transaction data fetching with TransactionService
- Calculates income, expenses, savings, and category breakdown
- Real-time metrics calculation when user filter changes
- Uses TransactionService.calculateReportMetrics() for business logic

**✅ Accounts Page** (`app/(dashboard)/accounts/`)
- Server-side user data fetching
- Ready for account service integration

### Architecture Pattern

All pages follow this optimized pattern using a **shared utility function**:

```typescript
// page.tsx - Server Component (DRY - Uses shared utility)
import { getDashboardData } from '@/lib/auth/get-dashboard-data';

export default async function PageName() {
  const { currentUser, groupUsers } = await getDashboardData();

  return (
    <Suspense fallback={<LoadingSkeleton />}>
      <PageContent currentUser={currentUser} groupUsers={groupUsers} />
    </Suspense>
  );
}

// page-content.tsx - Client Component
'use client';
import type { DashboardDataProps } from '@/lib/auth/get-dashboard-data';

export default function PageContent({ currentUser, groupUsers }: DashboardDataProps) {
  // Client-side state management
  const [selectedFilter, setSelectedFilter] = useState('all');

  return (
    <div>
      <UserSelector
        users={groupUsers}
        currentUser={currentUser}
        selectedGroupFilter={selectedFilter}
        onGroupFilterChange={setSelectedFilter}
      />
      {/* Rest of UI */}
    </div>
  );
}
```

**Benefits of Shared Utility (`getDashboardData`):**
- **DRY Principle** - Single source of truth for auth and data fetching
- **Consistency** - All pages handle errors the same way
- **Maintainability** - Update logic in one place, affects all pages
- **Type Safety** - `DashboardDataProps` interface for all content components
- **Reduced Code** - Each page is now ~10 lines instead of ~40 lines

### Performance Optimizations

1. **Server-Side Rendering**
   - All pages use Server Components for initial data fetch
   - User data cached for 5 minutes
   - Group data cached for 10 minutes
   - Reduced client bundle size

2. **Automatic Caching**
   - Next.js `unstable_cache` wraps all service methods
   - Request deduplication within same render
   - Tag-based invalidation for mutations

3. **Suspense Boundaries**
   - Progressive loading with skeletons
   - Better perceived performance
   - Granular error boundaries

4. **State Management**
   - Server data passed as props
   - Client state for interactivity
   - Minimal re-renders

### Next Steps (To Do)

**Services to Create:**
- ⬜ **AccountService** - Account CRUD, balance calculations
- ✅ **TransactionService** - Transaction operations, filtering, grouping, analytics ✅
- ⬜ **BudgetService** - Budget management, period calculations
- ⬜ **CategoryService** - Category operations
- ⬜ **InvestmentService** - Holdings, portfolio calculations
- ⬜ **RecurringService** - Recurring transaction series

**Features to Implement:**
- ⬜ Server Actions for data mutations
- ⬜ Cache invalidation on mutations
- ⬜ Optimistic UI updates
- ⬜ Real-time subscriptions (Supabase Realtime)
- ⬜ Error boundaries for each page
- ⬜ Loading states for async operations

**Content Components to Wire Up:**
When services are created, update these content components to use real data:
- `dashboard-content.tsx` - Add accounts, budgets, recurring data
- `accounts-content.tsx` - Add account list and balances
- ✅ `transactions-content.tsx` - Uses TransactionService for grouping and daily totals ✅
- `budgets-content.tsx` - Add budget data and progress
- `investments-content.tsx` - Add holdings and portfolio data
- ✅ `reports-content.tsx` - Uses TransactionService for metrics and analytics ✅

---

## Questions & Support

For questions about this architecture or adding new features:

1. **Read this documentation** first
2. **Check existing services** for patterns (UserService, GroupService)
3. **Follow SOLID principles** when creating new services
4. **Update this documentation** when adding new domains

---

**Last Updated**: 2025-01-15
**Version**: 1.1.0 - Implemented all pages with Server Components
**Author**: Claude Code (Anthropic)
